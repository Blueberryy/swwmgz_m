// Blackmann Arms "Wallbuster" Heavy Armor Perforator Shotgun (planned for unreleased Total Destruction UT mod as the "Armor Perforator")
// Slot 3, replaces Super Shotgun, Ethereal Crossbow, Frost Shards

Class WallbusterReloadMenu : GenericMenu
{
}

Class Wallbuster : SWWMWeapon
{
	Class<Ammo> loaded[25];
	bool fired[25];
	int rotation[6];
	bool initialized;
	Array<int> reloadqueue;
	transient bool waitreload;
	int whichspin;
	transient CVar cbtmuffler;

	transient ui TextureID WeaponBox, AmmoIcon[4], LoadIcon[4], UsedIcon[4], EmptyIcon;
	transient ui Font TewiFont;

	override void DrawWeapon( double TicFrac, double bx, double by, Vector2 hs, Vector2 ss )
	{
		static const Class<Ammo> types[] = {"RedShell","GreenShell","BlueShell","PurpleShell"};
		/*
		    (Layout of indices)

		             0
		           4   1
		            3 2
		       L           9
		     K   M       8   5
		      O N         7 6

		         H       D
		       G   I   C   E
		        F J     B A

		*/
		static const int barrelposx[] =
		{
			29,24,26,32,34,
			10,12,18,20,15,
			17,23,25,20,15,
			41,43,38,33,35,
			48,43,38,40,46
		};
		static const int barrelposy[] =
		{
			46,42,36,36,42,
			31,25,25,31,35,
			 8, 8,14,18,14,
			 8,14,18,14, 8,
			31,35,31,25,25
		};
		if ( !TewiFont ) TewiFont = Font.GetFont('TewiShaded');
		if ( !WeaponBox )
		{
			WeaponBox = TexMan.CheckForTexture("graphics/HUD/WallbusterDisplay.png",TexMan.Type_Any);
			AmmoIcon[0] = TexMan.CheckForTexture("graphics/HUD/RedShell.png",TexMan.Type_Any);
			AmmoIcon[1] = TexMan.CheckForTexture("graphics/HUD/GreenShell.png",TexMan.Type_Any);
			AmmoIcon[2] = TexMan.CheckForTexture("graphics/HUD/BlueShell.png",TexMan.Type_Any);
			AmmoIcon[3] = TexMan.CheckForTexture("graphics/HUD/PurpleShell.png",TexMan.Type_Any);
			LoadIcon[0] = TexMan.CheckForTexture("graphics/HUD/WallbusterRed.png",TexMan.Type_Any);
			LoadIcon[1] = TexMan.CheckForTexture("graphics/HUD/WallbusterGreen.png",TexMan.Type_Any);
			LoadIcon[2] = TexMan.CheckForTexture("graphics/HUD/WallbusterBlue.png",TexMan.Type_Any);
			LoadIcon[3] = TexMan.CheckForTexture("graphics/HUD/WallbusterPurple.png",TexMan.Type_Any);
			UsedIcon[0] = TexMan.CheckForTexture("graphics/HUD/WallbusterRedUsed.png",TexMan.Type_Any);
			UsedIcon[1] = TexMan.CheckForTexture("graphics/HUD/WallbusterGreenUsed.png",TexMan.Type_Any);
			UsedIcon[2] = TexMan.CheckForTexture("graphics/HUD/WallbusterBlueUsed.png",TexMan.Type_Any);
			UsedIcon[3] = TexMan.CheckForTexture("graphics/HUD/WallbusterPurpleUsed.png",TexMan.Type_Any);
			EmptyIcon = TexMan.CheckForTexture("graphics/HUD/WallbusterEmpty.png",TexMan.Type_Any);
		}
		Screen.DrawTexture(WeaponBox,false,bx-54,by-72,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
		int ox = 6;
		int oy = 60;
		for ( int i=0; i<4; i++ )
		{
			Screen.DrawTexture(AmmoIcon[i],false,bx-ox,by-oy,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
			String astr = String.Format("%3d",Owner.CountInv(types[i]));
			Screen.DrawText(TewiFont,Font.CR_FIRE,bx-ox-(TewiFont.StringWidth(astr)+1),by-oy-2,astr,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
			oy += 10;
			if ( i == 1 )
			{
				oy = 60;
				ox = 33;
			}
		}
		// and here's the big clusterdick
		for ( int i=0; i<25; i++ )
		{
			int idx = i;
			int group = idx/5;
			// shift based on group rotation
			int gidx = i%5;
			gidx = (gidx-rotation[group]);
			while ( gidx < 0 ) gidx += 5;
			idx = gidx+group*5;
			// shift based on full rotation
			idx = (idx-rotation[5]*5);
			while ( idx < 0 ) idx += 25;
			if ( !loaded[i] )
			{
				Screen.DrawTexture(EmptyIcon,false,bx-barrelposx[idx],by-barrelposy[idx],DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
				continue;
			}
			int which = 0;
			for ( int j=0; j<4; j++ )
			{
				if ( !(loaded[i] is types[j]) ) continue;
				which = j;
				break;
			}
			Screen.DrawTexture(fired[i]?UsedIcon[which]:LoadIcon[which],false,bx-barrelposx[idx],by-barrelposy[idx],DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
		}
	}

	override bool UsesAmmo( Class<Ammo> kind )
	{
		static const Class<Ammo> types[] = {"RedShell","GreenShell","BlueShell","PurpleShell"};
		for ( int i=0; i<4; i++ ) if ( kind is types[i] ) return true;
		return false;
	}
	override bool ReportHUDAmmo()
	{
		static const Class<Ammo> types[] = {"RedShell","GreenShell","BlueShell","PurpleShell"};
		for ( int i=0; i<4; i++ ) if ( Owner.CountInv(types[i]) > 0 ) return true;
		for ( int i=0; i<25; i++ ) if ( loaded[i] && !fired[i] ) return true;
		return false;
	}
	override bool CheckAmmo( int firemode, bool autoswitch, bool requireammo, int ammocount )
	{
		static const Class<Ammo> types[] = {"RedShell","GreenShell","BlueShell","PurpleShell"};
		if ( (firemode == PrimaryFire) || (firemode == AltFire) )
		{
			for ( int i=0; i<4; i++ ) if ( Owner.CountInv(types[i]) > 0 ) return true;
			for ( int i=0; i<25; i++ ) if ( loaded[i] && !fired[i] ) return true;
			return false;
		}
		return Super.CheckAmmo(firemode,autoswitch,requireammo,ammocount);
	}
	bool CanReload()
	{
		static const Class<Ammo> types[] = {"RedShell","GreenShell","BlueShell","PurpleShell"};
		for ( int i=0; i<4; i++ ) if ( Owner.CountInv(types[i]) > 0 ) return true;
		return false;
	}
	override void AttachToOwner( Actor other )
	{
		Super.AttachToOwner(other);
		if ( !initialized )
		{
			// first wallbuster is fully loaded
			initialized = true;
			for ( int i=0; i<25; i++ )
				loaded[i] = "RedShell";
			for ( int i=0; i<25; i++ )
				fired[i] = false;
		}
	}
	action void A_FireShells( int num = 1 )
	{
		static const Class<Ammo> types[] = {"RedShell","GreenShell","BlueShell","PurpleShell"};
		static const statelabel flashes[] = {"FlashRed","FlashGreen","FlashBlue","FlashPurple"};
		static const String sounds[] = {"spreadgun/redfire","spreadgun/greenfire","spreadgun/bluefire","spreadgun/purplefire"};
		static const Color cols[] = {Color(40,255,192,64),Color(36,255,192,80),Color(48,32,176,255),Color(24,255,224,96)};
		// speen
		if ( num == 1 ) invoker.whichspin = 1;
		else if ( num == 5 ) invoker.whichspin = 2;
		else invoker.whichspin = 0;
		// first pass, count fired rounds
		int howmany = 0;
		for ( int i=0; i<num; i++ )
		{
			int idx = i;
			// shift based on full rotation
			idx = (idx+invoker.rotation[5]*5);
			while ( idx > 24 ) idx -= 25;
			int group = idx/5;
			// shift based on group rotation
			int gidx = i%5;
			gidx = (gidx+invoker.rotation[group]);
			while ( gidx > 4 ) gidx -= 5;
			idx = gidx+group*5;
			if ( !invoker.loaded[idx] || invoker.fired[idx] ) continue;
			howmany++;
		}
		if ( howmany <= 0 )
		{
			A_StartSound("wallbuster/dryfire",CHAN_WEAPON,CHANF_OVERLAP);
			player.SetPsprite(PSP_WEAPON,ResolveState("DryFire"));
			return;
		}
		Vector3 x, y, z;
		[x, y, z] = swwm_CoordUtil.GetAxes(pitch,angle,roll);
		if ( !invoker.cbtmuffler ) invoker.cbtmuffler = CVar.GetCVar('swwm_earbuster',players[consoleplayer]);
		// second pass, actually fire them
		for ( int i=0; i<num; i++ )
		{
			int idx = i;
			// shift based on full rotation
			idx = (idx+invoker.rotation[5]*5);
			while ( idx > 24 ) idx -= 25;
			int group = idx/5;
			// shift based on group rotation
			int gidx = i%5;
			gidx = (gidx+invoker.rotation[group]);
			while ( gidx > 4 ) gidx -= 5;
			idx = gidx+group*5;
			if ( !invoker.loaded[idx] || invoker.fired[idx] ) continue;
			int which = 0;
			for ( int j=0; j<4; j++ )
			{
				if ( !(invoker.loaded[i] is types[j]) ) continue;
				which = j;
				break;
			}
			double rfact = invoker.cbtmuffler.GetBool()?.85:.65;
			A_StartSound(sounds[which],CHAN_WEAPON,CHANF_OVERLAP,1./(howmany**rfact),.6-howmany*.004,1.-howmany*.012);
			invoker.fired[idx] = true;
		}
		if ( howmany < 3 ) player.SetPsprite(PSP_WEAPON,ResolveState("FireOne"));
		else if ( howmany < 15 ) player.SetPsprite(PSP_WEAPON,ResolveState("FireFive"));
		else player.SetPsprite(PSP_WEAPON,ResolveState("FireTwentyFive"));
		int qk = min(9,1+howmany/5);
		int ql = min(25,6+howmany/2);
		A_QuakeEx(qk,qk,qk,ql,0,8,"",QF_RELATIVE|QF_SCALEDOWN,rollIntensity:qk*.15);
		A_ZoomFactor(1.+qk*.04,ZOOM_INSTANT);
		A_ZoomFactor(1.);
	}
	action void A_SpinOne()
	{
		A_StartSound("wallbuster/spin",CHAN_WEAPON,CHANF_OVERLAP);
		invoker.rotation[invoker.rotation[5]]++;
		while ( invoker.rotation[invoker.rotation[5]] > 4 ) invoker.rotation[invoker.rotation[5]] -= 5;
	}
	action void A_SpinBig()
	{
		A_StartSound("wallbuster/spinbig",CHAN_WEAPON,CHANF_OVERLAP);
		invoker.rotation[5]++;
		while ( invoker.rotation[5] > 4 ) invoker.rotation[5] -= 5;
	}
	action void A_HandSpin()
	{
		A_StartSound("wallbuster/handspin",CHAN_WEAPON,CHANF_OVERLAP);
		invoker.rotation[5]--;
		while ( invoker.rotation[5] < 0 ) invoker.rotation[5] += 5;
	}

	Default
	{
		Tag "$T_WALLBUSTER";
		Inventory.PickupMessage "$I_WALLBUSTER";
		Obituary "$O_WALLBUSTER";
		Weapon.SlotNumber 4;
		Weapon.SelectionOrder 2200;
		Weapon.UpSound "wallbuster/select";
		Weapon.AmmoType1 "RedShell";
		Weapon.AmmoGive1 25;
		Stamina 35000;
		+SWWMWEAPON.NOFIRSTGIVE;
	}
	States
	{
	Spawn:
		XZW1 A -1;
		Stop;
	Select:
		XZW2 G 1
		{
			A_FullRaise();
			Console.Printf("\cgWALLBUSTER NOT FULLY IMPLEMENTED\c-");
		}
		XZW2 HIJKLMNOP 2;
		Goto Ready;
	Ready:
		XZW2 A 1
		{
			int flg = WRF_ALLOWUSER1;
			if ( invoker.CheckAmmo(PrimaryFire,false) ) flg |= WRF_ALLOWZOOM;
			if ( invoker.CanReload() ) flg |= WRF_ALLOWRELOAD;
			A_WeaponReady(flg);
			if ( player.cmd.buttons&(BT_ATTACK|BT_ALTATTACK|BT_ZOOM) )
				invoker.CheckAmmo(EitherFire,true);
		}
		Wait;
	Fire:
		XZW2 A 0 A_FireShells(1);
		Goto FireOne;
	AltFire:
		XZW2 A 0 A_FireShells(5);
		Goto FireFive;
	Zoom:
		XZW2 A 0 A_FireShells(25);
		Goto FireTwentyFive;
	FireOne:
		XZW2 AQRSTUVWX 1;
		XZW2 A 0
		{
			if ( invoker.whichspin == 2 ) return ResolveState("BigSpin");
			if ( invoker.whichspin == 1 ) return ResolveState("OneSpin");
			return ResolveState("Ready");
		}
		Goto Ready;
	FireFive:
		XZW2 A 2;
		XZW3 CDEFGHIJK 2;
		XZW2 A 0
		{
			if ( invoker.whichspin == 2 ) return ResolveState("BigSpin");
			if ( invoker.whichspin == 1 ) return ResolveState("OneSpin");
			return ResolveState("Ready");
		}
		Goto Ready;
	FireTwentyFive:
		XZW2 A 2;
		XZW3 STUVWXYZ 2;
		XZW4 ABC 2;
		XZW2 A 0
		{
			if ( invoker.whichspin == 2 ) return ResolveState("BigSpin");
			if ( invoker.whichspin == 1 ) return ResolveState("OneSpin");
			return ResolveState("Ready");
		}
		Goto Ready;
	DryFire:
		XZW2 A 2;
		XZW2 XA 4;
		XZW2 A 0
		{
			if ( invoker.whichspin == 2 ) return ResolveState("BigSpin");
			if ( invoker.whichspin == 1 ) return ResolveState("OneSpin");
			return ResolveState("Ready");
		}
		Goto Ready;
	OneSpin:
		XZW2 A 1 A_SpinOne();
		XZW2 YZ 2;
		XZW3 A 2;
		XZW3 B 0;
		XZW2 A 0 A_JumpIf(invoker.rotation[invoker.rotation[5]]==0,"BigSpin");
		Goto Ready;
	BigSpin:
		XZW2 A 1 A_SpinBig();
		XZW3 LMNOPQ 2;
		XZW3 R 0;
		XZW2 A 0;
		Goto Ready;
	Reload:
		XZW2 A 1;
		Goto Ready;
	Detach:
		XZW2 A 1;
		Goto Ready;
	Attach:
		XZW2 A 1;
		Goto Ready;
	EndReload:
		XZW2 A 1;
		Goto Ready;
	User1:
		XZW2 A 2
		{
			A_StartSound("wallbuster/meleestart",CHAN_WEAPON,CHANF_OVERLAP);
			A_StartSound("demolitionist/wswing",CHAN_WEAPON,CHANF_OVERLAP);
		}
		XZW9 GHIJ 2;
		XZW9 K 1 A_Parry(9);
		XZW9 LMN 1;
		XZW9 O 2 A_Melee(70,"demolitionist/whitl");
		XZW9 PQRSTU 2;
		XZW9 V 2 A_StartSound("wallbuster/meleeend",CHAN_WEAPON,CHANF_OVERLAP);
		XZW9 WXYZ 2;
		XZWA ABCD 2;
		Goto Ready;
	Deselect:
		XZW2 A 2 A_StartSound("wallbuster/deselect",CHAN_WEAPON,CHANF_OVERLAP);
		XZW2 BCDEFG 2;
		XZW2 G -1 A_FullLower();
		Stop;
	}
}

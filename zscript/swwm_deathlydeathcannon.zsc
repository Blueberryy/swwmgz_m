// Ynykron Artifact (from UnSX Series, featured in SWWM Platinum as a secret weapon)
// Slot 0, replaces BFG9000, Firemace, Wraithverge (arc)

// cheap way to let players know they just got fucking erased from existence
Class PlayerGone : PlayerChunk
{
	int deadtimer;

	override void DeathThink()
	{
		player.damagecount--;
		player.poisoncount--;
		deadtimer++;
		if ( (deadtimer == 60) && (player == players[consoleplayer]) )
			A_StartSound("demolitionist/youdied",CHAN_DEMOVOICE,CHANF_OVERLAP|CHANF_UI);
		if ( multiplayer || level.AllowRespawn || sv_singleplayerrespawn || G_SkillPropertyInt(SKILLP_PlayerRespawn) )
		{
			// standard behaviour, respawn normally
			if ( (((player.cmd.buttons&BT_USE) && !player.Bot) || ((deathmatch || alwaysapplydmflags) && sv_forcerespawn && (Level.maptime >= player.respawn_time))) && !sv_norespawn )
			{
				player.cls = null;
				player.playerstate = PST_REBORN;
				if ( special1 > 2 ) special1 = 0;
			}
		}
		else if ( (player.cmd.buttons&BT_USE) && (deadtimer > 120) )
		{
			// gross hackfix for library "vanishing"
			SWWMExcuseMeWhatTheFuckHandler.ThisIsSomeSeriousBullshit();
			// reload save
			player.cls = null;
			player.playerstate = PST_ENTER;
			if ( special1 > 2 ) special1 = 0;
		}
		// no revive (for obvious reasons)
	}

	static void FeckOff( Actor p )
	{
		// doesn't affect voodoo dolls (convenient, isn't it?)
		if ( !p.player || (p.player.mo != p) ) return;
		let c = PlayerGone(Spawn("PlayerGone",(32767,32767,0)));
		c.player = p.player;
		c.Health = p.Health;
		p.player = null;
		c.ObtainInventory(p);
		if ( c.player ) c.player.mo = c;
		for ( int i=0; i<MAXPLAYERS; i++ )
		{
			if ( playeringame[i] && (players[i].camera == p) )
				players[i].camera = c;
		}
	}
}

Class IDontFeelSoGood : Thinker
{
	Actor goner;

	static void DeletThis( Actor whomst )
	{
		let ti = ThinkerIterator.Create("IDontFeelSoGood",STAT_USER);
		IDontFeelSoGood i;
		while ( i = IDontFeelSoGood(ti.Next()) )
			if ( i.goner == whomst ) return;
		i = new("IDontFeelSoGood");
		i.ChangeStatNum(STAT_USER);
		i.goner = whomst;
	}

	override void Tick()
	{
		if ( !goner )
		{
			Destroy();
			return;
		}
		if ( (goner.Health > 0) || (goner.tics != -1) ) return;
		goner.Destroy();
	}
}

Class YnykronImpactLight : PaletteLight
{
	Default
	{
		Tag "WhiteExpl2";
		ReactionTime 40;
		Args 0,0,0,300;
	}
}

Class YnykronShotLight : PaletteLight
{
	Default
	{
		Tag "WhiteExpl";
		ReactionTime 100;
		Args 0,0,0,1200;
	}
}

Class YnykronBeamLight : PaletteLight
{
	Default
	{
		Tag "WhiteExpl2";
		ReactionTime 80;
		Args 0,0,0,600;
	}
}

Class YnykronImpactArm : Actor
{
	Default
	{
		PROJECTILE;
		+THRUACTORS;
		+BOUNCEONWALLS;
		+BOUNCEONFLOORS;
		+BOUNCEONCEILINGS;
		+NODAMAGETHRUST;
		+FORCERADIUSDMG;
		-NOGRAVITY;
		Gravity 0.35;
		BounceFactor 1.0;
		Radius 4;
		Height 4;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		reactiontime = Random[ExploS](10,20);
		double ang, pt;
		ang = FRandom[ExploS](0,360);
		pt = FRandom[ExploS](-90,90);
		vel = (cos(ang)*cos(pt),sin(ang)*cos(pt),-sin(pt))*FRandom[ExploS](8.,20.);
	}
	States
	{
	Spawn:
		TNT1 A 1
		{
			A_CountDown();
			Spawn("YnykronImpactTrail",pos);
			Vector3 pvel = (FRandom[ExploS](-1,1),FRandom[ExploS](-1,1),FRandom[ExploS](-1,1)).unit()*FRandom[ExploS](1,5);
			let s = Spawn("SWWMSmoke",pos);
			s.vel = pvel+vel*.2;
			s.special1 = Random[ExploS](1,3);
			s.scale *= 2.4;
			s.alpha *= 0.1+.4*(ReactionTime/15.);
		}
		Wait;
	}
}

Class YnykronImpactTrail : Actor
{
	Default
	{
		RenderStyle "Add";
		+NOBLOCKMAP;
		+NOGRAVITY;
		+FORCEXYBILLBOARD;
		+NOTELEPORT;
		+NOINTERACTION;
		Scale 2.;
		Alpha .4;
	}
	States
	{
	Spawn:
		MOXP ABCDEFGHIJKLMNOPQRSTUVWXYZ[\ 1 Bright;
		Stop;
	}
}

Class YnykronImpact : Actor
{
	Default
	{
		Obituary "$O_YNYKRON";
		DamageType "Ynykron";
		RenderStyle "Add";
		Scale 4.;
		Alpha .4;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+NOTELEPORT;
		+DONTSPLASH;
		+NODAMAGETHRUST;
		+FORCERADIUSDMG;
		+FORCEXYBILLBOARD;
		+OLDRADIUSDMG;
		+EXTREMEDEATH;
		+NOINTERACTION;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		// no need to call A_AlertMonsters on this, all monsters on the entire map were already alerted by the initial shot
		A_QuakeEx(4,4,4,50,0,1200,"",QF_RELATIVE|QF_SCALEDOWN,falloff:600,rollintensity:.6);
		if ( YnykronShot(master) )
		{
			if ( YnykronShot(master).lastimpact < gametic )
			{
				master.A_StartSound("ynykron/hit",CHAN_VOICE,CHANF_OVERLAP,special2?.2:1.,.0);
				YnykronShot(master).lastimpact = gametic+(special2?3:5);
			}
		}
		else A_StartSound("ynykron/hit",CHAN_VOICE,CHANF_OVERLAP,special2?.2:1.,.0);
		Scale *= FRandom[ExploS](0.8,1.1);
		Scale.x *= RandomPick[ExploS](-1,1);
		Scale.y *= RandomPick[ExploS](-1,1);
		int numpt = Random[ExploS](3,5);
		for ( int i=0; i<numpt; i++ )
		{
			Vector3 pvel = (FRandom[ExploS](-1,1),FRandom[ExploS](-1,1),FRandom[ExploS](-1,1)).unit()*FRandom[ExploS](1,8);
			let s = Spawn("SWWMSmoke",pos);
			s.vel = pvel;
			s.special1 = Random[ExploS](2,10);
			s.scale *= 3.;
			s.alpha *= .4;
		}
		if ( bAMBUSH )
		{
			numpt = Random[ExploS](2,4);
			for ( int i=0; i<numpt; i++ )
			{
				Vector3 pvel = (FRandom[ExploS](-1,1),FRandom[ExploS](-1,1),FRandom[ExploS](-1,1)).unit()*FRandom[ExploS](2,24);
				let s = Spawn("SWWMChip",pos);
				s.vel = pvel;
			}
		}
		Spawn("YnykronImpactLight",pos);
		Spawn("YnykronImpactRing",pos);
		numpt = Random[ExploS](0,2);
		for ( int i=0; i<numpt; i++ )
		{
			let s = Spawn("YnykronImpactArm",pos);
			s.target = target;
		}
	}
	override void Tick()
	{
		Super.Tick();
		if ( isFrozen() ) return;
		special1++;
		if ( special1 != 3 ) return;
		SWWMHandler.DoBlast(self,400,15000);
		let bt = BlockThingsIterator.Create(self,500);
		while ( bt.Next() )
		{
			let t = bt.Thing;
			if ( !t || !t.bSHOOTABLE || !SWWMUtility.SphereIntersect(t,pos,300) || !CheckSight(t,SF_IGNOREVISIBILITY|SF_IGNOREWATERBOUNDARY) ) continue;
			if ( YnykronShot(master) && (YnykronShot(master).hitlist.Find(t) < YnykronShot(master).hitlist.Size()) )
				continue;
			Vector3 dirto = level.Vec3Diff(pos,t.Vec3Offset(0,0,t.Height/2));
			double dist = dirto.length();
			dirto /= dist;
			// voodoo dolls just get erased (how convenient)
			// otherwise instantly vaporize the fucker
			if ( t.player && (t.player.mo != t) ) t.Destroy();
			else t.DamageMobj(self,target,int.max,'Ynykron',DMG_FORCED|DMG_THRUSTLESS);
			if ( t && (t.Health <= 0) )
			{
				if ( t.player ) PlayerGone.FeckOff(t);
				// poof away
				t.bINVISIBLE = true;
				t.A_ChangeLinkFlags(false);	// remove from blockmap, should guarantee archviles not raising this
				IDontFeelSoGood.DeletThis(t);	// ensures corpse is deleted too
			}
			else if ( t && YnykronShot(master) )
				YnykronShot(master).hitlist.Push(t);
			if ( swwm_capmcrange && (special2 > 3) ) continue;
			// spawn blast that will propagate
			let b = Spawn("YnykronImpact",level.Vec3Offset(pos,dirto*min(300,dist)));
			b.target = target;
			b.master = master;
			b.angle = atan2(dirto.y,dirto.x);
			b.pitch = asin(-dirto.z);
			b.special2 = special2+(Random[Ynykron](0,4)?1:0);
			b.special1 = Random[Ynykron](-2,0);
			if ( YnykronShot(master) )
				YnykronShot(master).blastcount++;
		}
	}
	override void OnDestroy()
	{
		if ( YnykronShot(master) )
			YnykronShot(master).blastcount--;
		Super.OnDestroy();
	}
	States
	{
	Spawn:
		MOXP ABCDEFGHIJKLMNOPQRSTUVWXYZ[\ 2 Bright;
		Stop;
	}
}

Class YnykronTracer : LineTracer
{
	Actor ignore;
	Array<Line> ShootThroughList;
	Array<WaterHit> WaterHitList;
	Array<HitListEntry> HitList;

	override ETraceStatus TraceCallback()
	{
		// liquid splashes
		if ( Results.CrossedWater )
		{
			let hl = new("WaterHit");
			hl.sect = Results.CrossedWater;
			hl.hitpos = Results.CrossedWaterPos;
			WaterHitList.Push(hl);
		}
		else if ( Results.Crossed3DWater )
		{
			let hl = new("WaterHit");
			hl.sect = Results.Crossed3DWater;
			hl.hitpos = Results.Crossed3DWaterPos;
			WaterHitList.Push(hl);
		}
		if ( Results.HitType == TRACE_HitActor )
		{
			if ( Results.HitActor == ignore ) return TRACE_Skip;
			if ( Results.HitActor.bSHOOTABLE )
			{
				let ent = new("HitListEntry");
				ent.hitactor = Results.HitActor;
				ent.hitlocation = Results.HitPos;
				ent.x = Results.HitVector;
				hitlist.Push(ent);
			}
			return TRACE_Skip;
		}
		else if ( (Results.HitType == TRACE_HitWall) && (Results.Tier == TIER_Middle) )
		{
			if ( !Results.HitLine.sidedef[1] || (Results.HitLine.Flags&Line.ML_BlockHitscan) )
				return TRACE_Stop;
			ShootThroughList.Push(Results.HitLine);
			return TRACE_Skip;
		}
		return TRACE_Stop;
	}
}

Class YnykronBeamTrail : Actor
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		roll = FRandom[Ynykron](0,360);
		SetState(FindState("Spawn")+Random[Ynykron](0,8));
	}
	override void Tick()
	{
		if ( isFrozen() ) return;
		A_FadeOut(FRandom[Ynykron](.0005,.001));
		if ( !CheckNoDelay() || (tics == -1) ) return;
		if ( tics > 0 ) tics--;
		while ( !tics )
		{
			if ( !SetState(CurState.NextState) )
				return;
		}
	}
	Default
	{
		RenderStyle "Add";
		Radius 0.1;
		Height 0;
		Alpha .1;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+NOTELEPORT;
		+DONTSPLASH;
		+FORCEXYBILLBOARD;
		+ROLLSPRITE;
		+ROLLCENTER;
		+NOINTERACTION;
	}
	States
	{
	Spawn:
		MOTR ABCDEFGHI -1 Bright;
		Stop;
	}
}

Class YnykronBeam : Actor
{
	void SpreadOut()
	{
		Vector3 x, y, z;
		[x, y, z] = swwm_CoordUtil.GetAxes(pitch,angle,roll);
		let t = new("YnykronTracer");
		t.ignore = target;
		t.ShootThroughList.Clear();
		t.WaterHitList.Clear();
		t.HitList.Clear();
		t.Trace(pos,cursector,x,128,TRACE_HitSky);
		for ( int i=0; i<t.ShootThroughList.Size(); i++ )
		{
			t.ShootThroughList[i].Activate(target,0,SPAC_PCross);
			if ( t.ShootThroughList[i].special == GlassBreak )	// fuck glass
				t.ShootThroughList[i].Activate(target,0,SPAC_Impact);
		}
		for ( int i=0; i<t.WaterHitList.Size(); i++ )
		{
			let b = Spawn("InvisibleSplasher",t.WaterHitList[i].hitpos);
			b.A_CheckTerrain();
		}
		for ( int i=0; i<t.Results.Distance; i+=32 )
		{
			if ( Random[Ynykron](0,8) ) continue;
			let b = Spawn("SWWMSmoke",level.Vec3Offset(pos,x*i));
			b.Scale *= FRandom[Ynykron](1.6,1.8);
			b.special1 = Random[Ynykron](3,10);
			b.A_SetRenderStyle(.3,STYLE_AddShaded);
			b.vel += x*FRandom[Ynykron](.1,.5);
		}
		for ( int i=0; i<t.HitList.Size(); i++ )
		{
			if ( YnykronShot(master) && (YnykronShot(master).hitlist.Find(t.HitList[i].hitactor) < YnykronShot(master).hitlist.Size()) )
				continue;
			SWWMHandler.DoKnockback(t.hitlist[i].hitactor,x,15000);
			// voodoo dolls just get erased (how convenient)
			// otherwise instantly vaporize the fucker
			if ( t.hitlist[i].hitactor.player && (t.hitlist[i].hitactor.player.mo != t.hitlist[i].hitactor) ) t.hitlist[i].hitactor.Destroy();
			else t.hitlist[i].hitactor.DamageMobj(self,target,int.max,'Ynykron',DMG_FORCED|DMG_THRUSTLESS);
			if ( t.hitlist[i].hitactor && (t.hitlist[i].hitactor.Health <= 0) )
			{
				if ( t.hitlist[i].hitactor.player ) PlayerGone.FeckOff(t.hitlist[i].hitactor);
				// poof away
				t.hitlist[i].hitactor.bINVISIBLE = true;
				t.hitlist[i].hitactor.A_ChangeLinkFlags(false);	// remove from blockmap, should guarantee archviles not raising this
				IDontFeelSoGood.DeletThis(t.hitlist[i].hitactor);	// ensures corpse is deleted too
			}
			else if ( t.hitlist[i].hitactor && YnykronShot(master) )
				YnykronShot(master).hitlist.Push(t.hitlist[i].hitactor);
			// spawn blast that will propagate
			let b = Spawn("YnykronImpact",t.hitlist[i].hitlocation);
			b.target = target;
			b.master = master;
			b.angle = atan2(t.HitList[i].x.y,t.HitList[i].x.x);
			b.pitch = asin(-t.HitList[i].x.z);
			if ( YnykronShot(master) )
				YnykronShot(master).blastcount++;
		}
		if ( t.Results.HitType == TRACE_HasHitSky ) return;	// goodbye
		if ( t.Results.HitType != TRACE_HitNone )
		{
			// hit something
			Vector3 norm = -t.Results.HitVector;
			if ( t.Results.HitType == TRACE_HitWall )
			{
				norm = (t.Results.HitLine.delta.y,-t.Results.HitLine.delta.x,0).unit();
				if ( t.Results.Side ) norm *= -1;
				t.Results.HitLine.RemoteActivate(tracer,t.Results.Side,SPAC_Impact,t.Results.HitPos);
			}
			else if ( t.Results.HitType == TRACE_HitFloor )
			{
				if ( t.Results.ffloor ) norm = -t.Results.ffloor.top.Normal;
				else norm = t.Results.HitSector.floorplane.Normal;
			}
			else if ( t.Results.HitType == TRACE_HitCeiling )
			{
				if ( t.Results.ffloor ) norm = -t.Results.ffloor.bottom.Normal;
				else norm = t.Results.HitSector.ceilingplane.Normal;
			}
			let b = Spawn("YnykronImpact",level.Vec3Offset(t.Results.HitPos,norm*4));
			b.target = target;
			b.master = master;
			b.angle = atan2(norm.y,norm.x);
			b.pitch = asin(-norm.z);
			b.A_SprayDecal("YnykronBlast",-172);
			b.bAMBUSH = true;
			if ( YnykronShot(master) ) YnykronShot(master).blastcount++;
			// find exit point
			int maxdist = (25600-special1);
			for ( int i=128; i<maxdist; i++ )
			{
				Vector3 ofs = level.Vec3Offset(pos,x*i);
				if ( !level.IsPointInLevel(ofs) ) continue;
				// we got out, spawn a beam here (delayed)
				let next = Spawn("DelayedWallBeam",ofs);
				next.angle = atan2(x.y,x.x);
				next.pitch = asin(-x.z);
				next.roll = roll;
				next.target = target;
				next.master = master;
				next.special1 = special1+i;
				next.special2 = i/40;
				break;
			}
			return;
		}
		if ( ((special1%256) < 128) && !Random[Ynykron](0,3) )
			Spawn("YnykronBeamLight",level.Vec3Offset(pos,x*64));
		if ( special1 >= 25600 )
		{
			// end of the line, dissipate
			int numpt = Random[Ynykron](4,8);
			for ( int i=0; i<numpt; i++ )
			{
				let b = Spawn("SWWMSmoke",level.Vec3Offset(pos,x*128));
				b.Scale *= FRandom[Ynykron](.6,.8);
				b.special1 = Random[Ynykron](1,2);
				b.A_SetRenderStyle(.3,STYLE_AddShaded);
				b.SetShade(Color(255,255,255));
				b.vel += x*FRandom[Ynykron](0.,5.);
			}
			return;
		}
		// propagate
		let next = Spawn("YnykronBeam",level.Vec3Offset(pos,x*128));
		next.angle = atan2(x.y,x.x);
		next.pitch = asin(-x.z);
		next.roll = roll;
		next.target = target;
		next.master = master;
		next.special1 = special1+128;
		next.SetStateLabel("TrailSpawn");
	}
	override void PostBeginPlay()
	{
		if ( YnykronShot(master) )
			YnykronShot(master).beamcount++;
		// sprite trail
		Vector3 x, y, z;
		[x, y, z] = swwm_CoordUtil.GetAxes(pitch,angle,roll);
		for ( int i=0; i<128; i+=8 )
		{
			if ( Random[Ynykron](0,3) ) return;
			let t = Spawn("YnykronBeamTrail",level.Vec3Offset(pos,x*i));
			t.Scale *= .15+.0005*(special1+i);
		}
	}
	override void Tick()
	{
		if ( isFrozen() ) return;
		A_FadeOut(FRandom[Ynykron](.001,.002));
		special2++;
		if ( special2 == 2 )
			SpreadOut();
		if ( !CheckNoDelay() || (tics == -1) ) return;
		if ( tics > 0 ) tics--;
		while ( !tics )
		{
			if ( !SetState(CurState.NextState) )
				return;
		}
	}
	override void OnDestroy()
	{
		if ( YnykronShot(master) )
			YnykronShot(master).beamcount--;
		Super.OnDestroy();
	}
	Default
	{
		Obituary "$O_YNYKRON";
		DamageType "Ynykron";
		RenderStyle "Add";
		Radius .1;
		Height 0;
		Alpha .2;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+NOCLIP;
		+NOTELEPORT;
		+DONTSPLASH;
		+FORCEXYBILLBOARD;
		+ROLLSPRITE;
		+ROLLCENTER;
		+NODAMAGETHRUST;
		+FORCERADIUSDMG;
		+FOILINVUL;
		+EXTREMEDEATH;
		+NOINTERACTION;
	}
	States
	{
	Spawn:
		XZW1 A -1 Bright NoDelay
		{
			return FindState("StarterDev")+Random[Ynykron](0,3)*2;
		}
		Stop;
	TrailSpawn:
		XZW2 A -1 Bright
		{
			return FindState("TrailerDev")+Random[Ynykron](0,3)*2;
		}
		Stop;
	StarterDev:
		#### # 200 Bright;
		XZW1 B -1 Bright;
		Stop;
		#### # 200 Bright;
		XZW1 C -1 Bright;
		Stop;
		#### # 200 Bright;
		XZW1 D -1 Bright;
		Stop;
		#### # 200 Bright;
		XZW1 E -1 Bright;
		Stop;
	TrailerDev:
		#### # 200 Bright;
		XZW2 B -1 Bright;
		Stop;
		#### # 200 Bright;
		XZW2 C -1 Bright;
		Stop;
		#### # 200 Bright;
		XZW2 D -1 Bright;
		Stop;
		#### # 200 Bright;
		XZW2 E -1 Bright;
		Stop;
	}
}

Class DelayedWallBeam : Actor
{
	Default
	{
		Radius 0.1;
		Height 0;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+NOTELEPORT;
		+DONTSPLASH;
		+NOINTERACTION;
	}
	override void PostBeginPlay()
	{
		if ( YnykronShot(master) )
			YnykronShot(master).beamcount++;
	}
	override void Tick()
	{
		if ( isFrozen() ) return;
		special2--;
		if ( special2 > 0 ) return;
		if ( YnykronShot(master) )
			YnykronShot(master).beamcount--;
		let next = Spawn("YnykronBeam",pos);
		next.angle = angle;
		next.pitch = pitch;
		next.roll = roll;
		next.target = target;
		next.master = master;
		next.special1 = special1;
		next.SetStateLabel("TrailSpawn");
		// exit blast
		Vector3 x = (cos(angle)*cos(pitch),sin(angle)*cos(pitch),-sin(pitch));
		let b = Spawn("YnykronImpact",level.Vec3Offset(pos,x*4));
		b.target = target;
		b.master = master;
		b.angle = atan2(x.y,x.x);
		b.pitch = asin(-x.z);
		b.A_SprayDecal("YnykronBlast",-172);
		b.bAMBUSH = true;
		if ( YnykronShot(master) )
			YnykronShot(master).blastcount++;
		// trace back to get the proper "exit surface" so we can trigger lines if needed
		let at = new("AuxiliarySilverBulletTracer");
		at.Trace(pos,CurSector,-x,2.,TRACE_NoSky);
		if ( at.Results.HitType == TRACE_HitWall )
		{
			if ( at.Results.HitLine.sidedef[1] )
			{
				at.Results.HitLine.Activate(target,0,SPAC_PCross);
				if ( at.Results.HitLine.special == GlassBreak )	// fuck glass
					at.Results.HitLine.Activate(target,0,SPAC_Impact);
			}
			else at.Results.HitLine.Activate(tracer,at.Results.Side,SPAC_Impact);
		}
		Destroy();
	}
}

Class YnykronRing : Actor
{
	Default
	{
		RenderStyle "Add";
		Radius 0.1;
		Height 0;
		Scale .6;
		Alpha .3;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+FORCEXYBILLBOARD;
		+NOTELEPORT;
		+DONTSPLASH;
		+ROLLSPRITE;
		+ROLLCENTER;
		+NOINTERACTION;
	}
	States
	{
	Spawn:
		XRG4 ABCDEFGHIJKLMNOPQRSTUVWX 3 Bright;
		Stop;
	}
}

// non-model version, for impacts
Class YnykronImpactRing : YnykronRing
{
	Default
	{
		Scale 1.;
		Alpha .8;
	}
	States
	{
	Spawn:
		XRG4 ABCDEFGHIJKLMNOPQRSTUVWX 1 Bright A_SetScale(scale.x*1.02);
		Stop;
	}
}

Class YnykronShot : Actor
{
	Array<Actor> hitlist;
	int beamcount;
	int blastcount;
	int lastimpact;

	Default
	{
		Radius .1;
		Height 0;
		+NOGRAVITY;
		+NOBLOCKMAP;
		+NOTELEPORT;
		+DONTSPLASH;
		+NOINTERACTION;
	}
	override void PostBeginPlay()
	{
		A_QuakeEx(6,6,6,150,0,65536,"",QF_RELATIVE|QF_SCALEDOWN,falloff:65536,rollIntensity:1.);
		A_StartSound("ynykron/beam",CHAN_VOICE,CHANF_DEFAULT,1.,0.);
		hitlist.Clear();
		beamcount = 0;
		blastcount = 0;
		int rings = 1;
		Vector3 x, y, z, dir;
		double a, s;
		[x, y, z] = swwm_CoordUtil.GetAxes(pitch,angle,roll);
		for ( double i=0; i<.05; i+=.01 )
		{
			for ( int j=0; j<360; j+=(360/rings) )
			{
				if ( i==0 ) dir = x;	// central beam always precise
				else
				{
					a = j+FRandom[Ynykron](-5.,5.);
					s = i+FRandom[Ynykron](-.02,.02);
					dir = (x+y*cos(a)*s+z*sin(a)*s).unit();
				}
				let b = Spawn("YnykronBeam",pos);
				b.target = target;
				b.master = self;
				b.angle = atan2(dir.y,dir.x);
				b.pitch = asin(-dir.z);
				b.roll = FRandom[Ynykron](0,360);
			}
			rings += 4;
		}
		Spawn("YnykronShotLight",level.Vec3Offset(pos,x*30));
	}
	override void Tick()
	{
		if ( isFrozen() ) return;
		// spawn rings
		special1++;
		if ( !(special1%10) && (special1 <= 30) )
		{
			Vector3 dir = (cos(angle)*cos(pitch),sin(angle)*cos(pitch),-sin(pitch));
			for ( int i=0; i<16; i++ )
			{
				let r = Spawn("YnykronRing",level.Vec3Offset(pos,dir*(special1*16+i*2)));
				r.scale *= special1/8.;
				r.angle = angle;
				r.pitch = pitch;
				r.roll = FRandom[Ynykron](0,360);
			}
		}
		// wait until we're no longer needed and all effects are over
		if ( IsActorPlayingSound(CHAN_VOICE) || (beamcount > 0) || (blastcount > 0) )
		{
			special1 = min(special1,50);
			return;
		}
		// we're done here, but wait for a while just in case
		if ( special1 > 350 ) Destroy();
	}
}

Class Ynykron : SWWMWeapon
{
	transient ui TextureID WeaponBox, ChargeBar[2], BoxSide[2];
	transient ui Font TewiFont;
	transient ui DynamicValueInterpolator ChargeInter;

	enum EChargeState
	{
		CS_IDLE,
		CS_CHARGING,
		CS_READY,
		CS_DISCHARGING
	};

	int chargestate;
	double chargelevel;
	bool inverted;

	double ventalpha, ventfade;
	int ventcooldown;

	int clipcount;

	Property ClipCount : clipcount;

	override void DrawWeapon( double TicFrac, double bx, double by, Vector2 hs, Vector2 ss )
	{
		if ( !WeaponBox ) WeaponBox = TexMan.CheckForTexture("graphics/HUD/YnykronDisplay.png",TexMan.Type_Any);
		if ( !ChargeBar[0] ) ChargeBar[0] = TexMan.CheckForTexture("graphics/HUD/YnykronBarA.png",TexMan.Type_Any);
		if ( !ChargeBar[1] ) ChargeBar[1] = TexMan.CheckForTexture("graphics/HUD/YnykronBarB.png",TexMan.Type_Any);
		if ( !BoxSide[0] ) BoxSide[0] = TexMan.CheckForTexture("graphics/HUD/YnykronSideA.png",TexMan.Type_Any);
		if ( !BoxSide[1] ) BoxSide[1] = TexMan.CheckForTexture("graphics/HUD/YnykronSideB.png",TexMan.Type_Any);
		if ( !TewiFont ) TewiFont = Font.GetFont('TewiShaded');
		Screen.DrawTexture(WeaponBox,false,bx-33,by-44,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
		int chg = clamp(ChargeInter?ChargeInter.GetValue():int(chargelevel*10),0,400);
		int ct = int(((by-2)-chg/10.)*hs.y);
		Screen.DrawText(TewiFont,Font.CR_FIRE,bx-30,by-16,String.Format("%d",Ammo1.Amount),DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true);
		Screen.DrawTexture(BoxSide[inverted],false,bx-23,by-31,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_ColorOverlay,clipcount?Color(0,0,0,0):Color(128,0,0,0));
		Screen.DrawTexture(ChargeBar[inverted],false,bx-6,by-42,DTA_VirtualWidthF,ss.x,DTA_VirtualHeightF,ss.y,DTA_KeepRatio,true,DTA_ColorOverlay,(chargestate==CS_READY)?Color(int(clamp(sin((level.maptime+TicFrac)*8)*40+24,0.,64.)),255,255,255):Color(0,0,0,0),DTA_ClipTop,ct);
	}
	override void HudTick()
	{
		if ( !ChargeInter ) ChargeInter = DynamicValueInterpolator.Create(int(chargelevel*10),.5,1,400);
		ChargeInter.Update(int(chargelevel*10));
	}

	override bool ReportHUDAmmo()
	{
		if ( clipcount > 0 ) return true;
		return Super.ReportHUDAmmo();
	}
	override bool CheckAmmo( int firemode, bool autoswitch, bool requireammo, int ammocount )
	{
		if ( sv_infiniteammo || Owner.FindInventory('PowerInfiniteAmmo',true) ) return true;
		if ( (fireMode == PrimaryFire) || (fireMode == AltFire) )
			return ((clipcount > 0) || (Ammo1.Amount > 0));
		return Super.CheckAmmo(firemode,autoswitch,requireammo,ammocount);
	}

	override void Travelled()
	{
		Super.Travelled();
		if ( Owner.player && (Owner.player.Readyweapon == self) )
		{
			Owner.A_StartSound("ynykron/idle",CHAN_WEAPONEXTRA,CHANF_LOOPING,.3,4.);
			if ( chargestate > CS_IDLE )
				Owner.A_StartSound("ynykron/ready",CHAN_WEAPONEXTRA2,CHANF_LOOPING,(.025*chargelevel)**3.,2.);
		}
	}

	action void A_YnykronFire()
	{
		A_SWWMFlash();
		A_StopSound(CHAN_WEAPONEXTRA2);
		A_StartSound(invoker.inverted?"ynykron/altfire":"ynykron/fire",CHAN_WEAPON,CHANF_OVERLAP,1.,.0);
		// alert everyone in the entire map
		int ns = level.Sectors.Size();
		for ( int i=0; i<ns; i++ )
		{
			Sector s = level.Sectors[i];
			for ( Actor a=s.thinglist; a; a=a.snext )
				a.LastHeard = self;
		}
		A_QuakeEx(9,9,9,4,0,1,"",QF_RELATIVE|QF_SCALEDOWN,rollIntensity:2.5);
		A_ZoomFactor(.7,ZOOM_INSTANT);
		A_ZoomFactor(1.);
		A_PlayerFire();
		SWWMHandler.DoFlash(self,Color(120,255,255,255),30);
		A_Overlay(PSP_WEAPON+1,"FireSmoke");
		A_OverlayFlags(PSP_WEAPON+1,PSPF_RENDERSTYLE|PSPF_ALPHA|PSPF_FORCESTYLE|PSPF_FORCEALPHA,true);
		A_OverlayRenderStyle(PSP_WEAPON+1,STYLE_Add);
		A_OverlayAlpha(PSP_WEAPON+1,0.);
		invoker.chargestate = CS_IDLE;
		invoker.clipcount = 0;
		Vector3 x, y, z, origin;
		[x, y, z] = swwm_CoordUtil.GetAxes(pitch,angle,roll);
		origin = level.Vec3Offset(Vec2OffsetZ(0,0,player.viewz),x*15+y*4);
		if ( invoker.inverted )
		{
			// TODO altfire
			Console.Printf("\cgYNYKRON ALTFIRE NOT DONE, FALLBACK TO PRIMARY\c-");
		}
		//else
		{
			let s = Spawn("YnykronShot",origin);
			s.target = self;
			s.angle = angle;
			s.pitch = BulletSlope();
		}
		invoker.specialf1 = 1.;
		A_Overlay(PSP_WEAPON+3,"FireBlast");
	}

	action void A_Backblast()
	{
		Vector3 x, y, z, origin;
		[x, y, z] = swwm_CoordUtil.GetAxes(pitch,angle,roll);
		origin = level.Vec3Offset(Vec2OffsetZ(0,0,player.viewz),-x*15+y*4);
		int numpt = Random[Ynykron](40,80);
		for ( int i=0; i<numpt; i++ )
		{
			let s = Spawn("SWWMSmoke",origin);
			s.scale *= 2.4;
			s.alpha *= .4*invoker.specialf1;
			s.special1 = Random[Ynykron](2,8);
			s.vel += x*FRandom[Ynykron](-40.,-4.)*invoker.specialf1+y*FRandom[Ynykron](-1.,1.)+z*FRandom[Ynykron](-1.,1.);
		}
		invoker.specialf1 -= .2;
	}

	override void DoEffect()
	{
		Super.DoEffect();
		if ( chargestate == CS_IDLE ) chargelevel = 0.;
		else if ( chargestate == CS_CHARGING )
		{
			chargelevel = min(chargelevel*0.997+.16,40.);
			if ( chargelevel >= 40. )
			{
				if ( (Owner.player.ReadyWeapon != self) && (Owner.player == players[consoleplayer]) )
					Console.Printf(StringTable.Localize("$SWWM_YNYKRONREADY"));
				chargestate = CS_READY;
			}
			if ( Owner.player.ReadyWeapon == self )
				Owner.A_SoundVolume(CHAN_WEAPONEXTRA2,(.025*chargelevel)**3.);
		}
		if ( Owner.player.ReadyWeapon != self ) return;
		let pspm = Owner.player.FindPSprite(PSP_WEAPON);
		if ( pspm )
		{
			double shiver = (chargelevel*.025)**2.;
			pspm.x = FRandom[Shivers](-1.,1.)*shiver;
			pspm.y = 32+FRandom[Shivers](-1.,1.)*shiver;
		}
		let psp = Owner.player.FindPSprite(PSP_WEAPON+1);
		if ( !psp ) return;
		ventalpha = clamp(ventalpha+ventfade,0.,1.);
		psp.alpha = ventalpha;
		if ( chargestate == CS_DISCHARGING )
		{
			chargelevel = max(chargelevel*1.005-.24,0.);
			if ( chargelevel <= 0. ) chargestate = CS_IDLE;
			if ( Owner.player.ReadyWeapon == self )
				Owner.A_SoundVolume(CHAN_WEAPONEXTRA2,(.025*chargelevel)**3.);
		}
	}

	Default
	{
		Tag "$T_YNYKRON";
		Inventory.PickupMessage "$T_YNYKRON";
		Obituary "$O_YNYKRON";
		Inventory.Icon "graphics/HUD/Icons/W_Ynykron.png";
		Weapon.SlotNumber 0;
		Weapon.SelectionOrder 1000;
		Weapon.UpSound "ynykron/select";
		Stamina 5000000;
		Weapon.AmmoType1 "YnykronAmmo";
		Weapon.AmmoGive1 1;
		+SWWMWEAPON.NOFIRSTGIVE;
		Ynykron.ClipCount 1;
		+WEAPON.NO_AUTO_SWITCH;
	}
	States
	{
	Spawn:
		XZW1 A -1;
		Stop;
	Select:
		XZW2 L 2
		{
			invoker.ventcooldown = Random[Ynykron](6,15);
			A_StartSound("ynykron/idle",CHAN_WEAPONEXTRA,CHANF_LOOPING,.3,4.);
			if ( invoker.chargelevel > 0. )
				A_StartSound("ynykron/ready",CHAN_WEAPONEXTRA2,CHANF_LOOPING,(.025*invoker.chargelevel)**3.,2.);
			A_FullRaise();
		}
		XZW2 MNOPQRSTUVWXYZ 2;
		XZW3 A 2;
		Goto Ready;
	Ready:
		XZW2 A 1
		{
			if ( invoker.chargestate == CS_DISCHARGING )
				return ResolveState("Discharge");
			int flg = WRF_ALLOWZOOM|WRF_ALLOWUSER1;
			if ( (invoker.chargestate > CS_IDLE) || ((invoker.clipcount <= 0) && ((invoker.Ammo1.Amount > 0) || sv_infiniteammo || FindInventory('PowerInfiniteAmmo',true))) )
				flg |= WRF_ALLOWRELOAD;
			if ( (invoker.clipcount <= 0) || (invoker.chargestate > CS_IDLE) )
				flg |= WRF_NOSECONDARY;
			if ( invoker.chargestate == CS_CHARGING )
				flg |= WRF_NOPRIMARY;
			A_WeaponReady(flg);
			if ( invoker.chargelevel >= 20. )
			{
				invoker.ventcooldown--;
				if ( invoker.ventcooldown <= 0 )
					return ResolveState("ReadyVent");
			}
			if ( player.cmd.buttons&BT_ATTACK )
				invoker.CheckAmmo(EitherFire,true);
			return ResolveState(null);
		}
		Wait;
	ReadyVent:
		XZW2 A 1
		{
			invoker.ventcooldown = Random[Ynykron](10,15)*5+2*(40-int(invoker.chargelevel));
			A_Overlay(PSP_WEAPON+1,"ReadyVentSmoke");
			A_OverlayFlags(PSP_WEAPON+1,PSPF_RENDERSTYLE|PSPF_ALPHA|PSPF_FORCESTYLE|PSPF_FORCEALPHA,true);
			A_OverlayRenderStyle(PSP_WEAPON+1,STYLE_Add);
			A_OverlayAlpha(PSP_WEAPON+1,0.);
			A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
			A_StartSound("ynykron/ventopen",CHAN_WEAPON,CHANF_OVERLAP);
		}
		XZWA ABCDEF 2 A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
		XZWA G 2
		{
			A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
			A_StartSound("ynykron/ventclose",CHAN_WEAPON,CHANF_OVERLAP);
		}
		XZWA HI 2 A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
		Goto Ready;
	ReadyVentSmoke:
		XZWB D 1
		{
			invoker.ventfade = .3;
			A_StartSound("ynykron/puff",CHAN_WEAPON,CHANF_OVERLAP);
		}
		XZWB EF 2;
		XZWB G 2
		{
			invoker.ventfade = -.1;
		}
		XZWB HIJKLM 2;
		Stop;
	Fire:
		XZW2 A 1
		{
			if ( (invoker.clipcount <= 0) && ((invoker.Ammo1.Amount > 0) || sv_infiniteammo || FindInventory('PowerInfiniteAmmo',true)) )
				return ResolveState("Reload");
			if ( invoker.chargestate == CS_IDLE )
				return ResolveState("Charge");
			A_YnykronFire();
			A_StartSound("ynykron/ventopen",CHAN_WEAPON,CHANF_OVERLAP);
			return ResolveState(null);
		}
		XZW3 JK 2;
		XZW3 LMNOP 3;
		XZW3 Q 3 A_StartSound("ynykron/ventclose",CHAN_WEAPON,CHANF_OVERLAP);
		XZW3 R 3;
		Goto Ready;
	FireBlast:
		TNT1 AAAAA 1 A_Backblast();
		Stop;
	FireSmoke:
		XZWA J 1
		{
			invoker.ventfade = .3;
			A_StartSound("ynykron/puff",CHAN_WEAPON,CHANF_OVERLAP);
		}
		XZWA KLMNO 2;
		XZWA P 3
		{
			invoker.ventfade = -.1;
		}
		XZWA QRS 3;
		Stop;
	AltFire:
		XZW2 A 2
		{
			A_StartSound("ynykron/meleestart",CHAN_WEAPON,CHANF_OVERLAP);
			return A_JumpIf(invoker.inverted,"TakeInverted");
		}
	TakeNormal:
		XZW3 STU 2;
		XZW3 V 2
		{
			A_StartSound("ynykron/magout",CHAN_WEAPON,CHANF_OVERLAP);
			A_PlayerReload();
		}
		XZW3 WXYZ 2;
		XZW4 ABCDEFGHIJKLMNO 2;
		XZW4 P 0
		{
			invoker.inverted = true;
		}
		Goto PutInverted;
	TakeInverted:
		XZW5 PQRS 2;
		XZW5 T 2
		{
			A_StartSound("ynykron/magout",CHAN_WEAPON,CHANF_OVERLAP);
			A_PlayerReload();
		}
		XZW5 UVWXYZ 2;
		XZW6 ABCDEFGHIJKLM 2;
		XZW6 N 0
		{
			invoker.inverted = false;
		}
		Goto PutNormal;
	PutNormal:
		XZW4 PQRS 2;
		XZW4 T 2 A_StartSound("ynykron/magin",CHAN_WEAPON,CHANF_OVERLAP);
		XZW4 UVWXYZ 2;
		XZW5 A 2 A_StartSound("ynykron/meleeend",CHAN_WEAPON,CHANF_OVERLAP);
		XZW5 BCDEFGHIJK 2;
		XZW5 L 4;
		Goto Ready;
	PutInverted:
		XZW6 NOPQ 2;
		XZW6 R 2 A_StartSound("ynykron/magin",CHAN_WEAPON,CHANF_OVERLAP);
		XZW6 STUVWXY 2;
		XZW6 Z 2 A_StartSound("ynykron/meleeend",CHAN_WEAPON,CHANF_OVERLAP);
		XZW7 ABCDEFGHIJ 2;
		XZW7 K 4;
		XZW5 P 0;
		Goto Ready;
	Discharge:
		XZW2 A 2;
		XZW7 NO 2;
		XZW7 P 2 A_StartSound("ynykron/latch",CHAN_WEAPON,CHANF_OVERLAP);
		XZW7 Q 2
		{
			invoker.chargestate = CS_DISCHARGING;
			A_Overlay(PSP_WEAPON+1,"DischargeSmoke");
			A_OverlayFlags(PSP_WEAPON+1,PSPF_RENDERSTYLE|PSPF_ALPHA|PSPF_FORCESTYLE|PSPF_FORCEALPHA,true);
			A_OverlayRenderStyle(PSP_WEAPON+1,STYLE_Add);
			A_OverlayAlpha(PSP_WEAPON+1,0.);
			A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
			A_StartSound("ynykron/ventopen",CHAN_WEAPON,CHANF_OVERLAP);
		}
		XZW7 RSTUV 2 A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
		XZW7 W 2
		{
			A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
			return A_JumpIf(invoker.chargestate==CS_IDLE,1);
		}
		Wait;
		XZW7 W 3 A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
		XZW7 X 2
		{
			A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
			A_StartSound("ynykron/ventclose",CHAN_WEAPON,CHANF_OVERLAP);
		}
		XZW7 YZ 2 A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
		Goto Ready;
	DischargeSmoke:
		XZWA T 2
		{
			invoker.ventfade = .3;
			A_StartSound("ynykron/puffing",CHAN_WEAPONEXTRA3,CHANF_LOOPING);
		}
		XZWA UVWXY 2;
		XZWA Z 2 A_JumpIf(invoker.chargestate==CS_IDLE,1);
		Wait;
		XZWA Z 3
		{
			invoker.ventfade = -.1;
			A_SoundVolume(CHAN_WEAPONEXTRA3,.8);
			A_StartSound("ynykron/puffend",CHAN_WEAPON,CHANF_OVERLAP);
		}
		XZWB A 2 A_SoundVolume(CHAN_WEAPONEXTRA3,.6);
		XZWB B 2 A_SoundVolume(CHAN_WEAPONEXTRA3,.4);
		XZWB C 2 A_SoundVolume(CHAN_WEAPONEXTRA3,.2);
		XZWB D 2 A_StopSound(CHAN_WEAPONEXTRA3);
		Stop;
	Charge:
		XZW2 A 2;
		XZW3 BC 2;
		XZW3 D 2 A_StartSound("ynykron/latch",CHAN_WEAPON,CHANF_OVERLAP);
		XZW3 EFGHI 2;
		XZW2 A 0
		{
			invoker.chargestate = CS_CHARGING;
			invoker.ventcooldown = Random[Ynykron](6,15);
			A_StartSound("ynykron/ready",CHAN_WEAPONEXTRA2,CHANF_LOOPING,.01,2.);
		}
		Goto Ready;
	Reload:
		XZW2 A 2
		{
			if ( invoker.chargestate>CS_IDLE ) return ResolveState("Discharge");
			if ( invoker.inverted ) return ResolveState("UnloadInverted");
			A_StartSound("ynykron/meleestart",CHAN_WEAPON,CHANF_OVERLAP);
			return ResolveState(null);
		}
	UnloadNormal:
		XZW3 STU 2;
		XZW3 V 2 A_StartSound("ynykron/magout",CHAN_WEAPON,CHANF_OVERLAP);
		XZW3 WXYZ 2;
		XZW4 ABCDEFGHIJKLMNO 2;
		XZW4 P 0
		{
			if ( !sv_infiniteammo && !FindInventory('PowerInfiniteAmmo',true) )
				invoker.Ammo1.Amount = max(invoker.Ammo1.Amount-1,0);
			invoker.clipcount = 1;
			invoker.inverted = false;
			// no mag is dropped, depleted crystals are hazardous and should be disposed of properly
		}
		Goto PutNormal;
	UnloadInverted:
		XZW5 PQRS 2;
		XZW5 T 2 A_StartSound("ynykron/magout",CHAN_WEAPON,CHANF_OVERLAP);
		XZW5 UVWXYZ 2;
		XZW6 ABCDEFGHIJKLM 2;
		XZW6 N 0
		{
			if ( !sv_infiniteammo && !FindInventory('PowerInfiniteAmmo',true) )
				invoker.Ammo1.Amount = max(invoker.Ammo1.Amount-1,0);
			invoker.clipcount = 1;
			invoker.inverted = false;
			// no mag is dropped, depleted crystals are hazardous and should be disposed of properly
		}
		Goto PutNormal;
	Zoom:
		XZW2 A 2
		{
			invoker.ventcooldown = Random[Ynykron](6,15);
			A_StartSound("ynykron/checkout",CHAN_WEAPON,CHANF_OVERLAP);
			A_PlayerCheckGun();
		}
		XZW8 ABCDEFGHIJKLMNOPQRSTUVW 2;
		XZW8 X 4;	// smoothen more
		Goto Ready;
	User1:
		XZW2 A 2
		{
			invoker.ventcooldown = Random[Ynykron](6,15);
			A_StartSound("ynykron/meleestart",CHAN_WEAPON,CHANF_OVERLAP);
			A_StartSound("demolitionist/wswing",CHAN_WEAPON,CHANF_OVERLAP);
			A_PlayerMelee();
		}
		XZW8 YZ 2;
		XZW9 AB 2;
		XZW9 C 1 A_Parry(9);
		XZW9 DE 1;
		XZW9 F 1 A_Melee(100,"demolitionist/whitl",1.5);
		XZW9 GHIJK 1;
		XZW9 LMNO 2;
		XZW9 P 2 A_StartSound("ynykron/meleeend",CHAN_WEAPON,CHANF_OVERLAP);
		XZW9 QRSTUVWXYZ 2;
		Goto Ready;
	Deselect:
		XZW2 A 2 A_StartSound("ynykron/deselect",CHAN_WEAPON,CHANF_OVERLAP);
		XZW2 BCDEFGHIJK 2;
		XZW2 L -1
		{
			A_StopSound(CHAN_WEAPONEXTRA);
			A_StopSound(CHAN_WEAPONEXTRA2);
			A_FullLower();
		}
		Stop;
	Flash:
		XZWZ A 2 Bright
		{
			let l = Spawn("SWWMWeaponLight",pos);
			l.args[0] = 255;
			l.args[1] = 255;
			l.args[2] = 255;
			l.args[3] = 500;
			l.target = self;
		}
		Stop;
	}
}
